# 4.2.1 Graphics Engine Technical Specification

**Project:** Bones on Ice - Web Edition v1.0
**Audience:** Graphics Engine Developer (PixiJS or equivalent)
**Purpose:** To define the required visual components, their states, their APIs, and their animations for implementation.

---

## 1. Core Principle: The "Dumb Renderer"

The Graphics Engine is a "dumb" renderer. It contains **NO game logic**. Its sole responsibility is to listen for events emitted by the main Game Engine and execute the corresponding visual actions. It manages the canvas, sprites, and animations, but does not track score, turns, or rules.

## 2. Scene Architecture & Rendering Layers

The main stage will be composed of strictly ordered layers (containers) to ensure correct z-indexing. The developer must implement this layering.

1.  **`BACKGROUND_LAYER`**: Renders the static base rink texture and underlying patterns.
2.  **`BOARD_LAYER`**: Renders the interactive zones and their highlighting/glow effects.
3.  **`TOKEN_LAYER`**: Renders all player and puck tokens.
4.  **`VFX_LAYER`**: Renders in-world particle effects and floating text (`+2`, "Blocked!"). This sits on top of tokens.
5.  **`UI_OVERLAY_LAYER`**: Renders transient, full-screen overlays like the dice rolling container.
6.  **`MODAL_LAYER`**: The absolute top layer for game menus, settings, or end-of-match summaries.

## 3. Detailed Component Specifications

### 3.1. `BoardRenderer`
*   **Task:** Manage the visual state of the three main zones.
*   **API:**
    *   `board.highlightZone(zoneId, options)`
        *   `options` is an object: `{ color: string, intensity: float, pulse: boolean, pulseSpeed: float }`.
        *   `pulse: true` should trigger a smooth, sinusoidal oscillation of the `intensity`.
    *   `board.clearHighlight(zoneId)`
    *   `board.clearAllHighlights()`

### 3.2. `TokenRenderer`
*   **Task:** Manage the visual representation and animation of all player tokens. **Object Pooling** must be used for tokens to optimize performance.
*   **API:**
    *   `token.setState(stateName)`: Transitions smoothly between states over ~200ms (e.g., a cross-fade from `default` to `hasActed`).
    *   `token.moveTo(targetCoords, duration)`: Tweens the token's position over `duration` ms. **Must use an 'easeInOutCubic' easing function** to create a natural acceleration and deceleration.
    *   `token.attachPuck(puckObject)`
    *   `token.detachPuck()`

### 3.3. `DiceRenderer`
*   **Task:** Execute the high-impact dice roll animation. This is a critical visual moment.
*   **API:**
    *   `dice.roll(diceConfig, results)`
        *   `diceConfig`: Array of strings, e.g., `['d8', 'd10']`.
        *   `results`: Corresponding array of numbers, e.g., `[5, 7]`.
*   **Animation Sequence (Detailed):**
    1.  On `roll()` call, create a full-screen, semi-transparent dark overlay on the `UI_OVERLAY_LAYER`.
    2.  Instantiate the specified dice sprites in the center of the overlay.
    3.  **Physics are faked:** The final result is predetermined by the `results` array.
    4.  Apply an initial impulse: a random upward vector and a random angular velocity to each die.
    5.  Animate for a fixed duration (~1.5s). The dice should appear to slow down due to "friction."
    6.  In the last 300ms of the animation, tween the dice rotation to smoothly land on the predetermined face from the `results` array.
    7.  Hold the final result for 1 second, then fade out the entire overlay and dice.

### 3.4. `VFXManager`
*   **Task:** Manage a library of pre-canned particle effects. **Object Pooling** must be used for particles.
*   **API:**
    *   `vfx.play(effectName, options)`
        *   `options`: e.g., `{ position: {x, y}, color: '#RRGGBB', scale: float }`.
*   **Required Effects Library (`effectName`):**
    *   `goalScored`: Screen-wide flash followed by shattering ice particles from the goal line.
    *   `actionBlocked`: A hexagonal "energy shield" impact at the point of collision.
    *   `teamSpirit_svarog`: An anvil/hammer glyph with fiery sparks.
    *   `teamSpirit_winds`: A swirling vortex of snow/wind particles.
    *   `(etc. for all 6 teams)`

### 3.5. `InWorldTextManager`
*   **Task:** Manage floating text/numbers on the board. **Object Pooling** must be used.
*   **API:**
    *   `textManager.spawn(text, options)`
        *   `options`: `{ position, color, fontSize, duration, animationType: 'pop' | 'floatUp' }`.
*   **Animation Types:**
    *   `pop`: Text scales up from 0 to 100% quickly, holds, then fades out.
    *   `floatUp`: Text appears and slowly floats upward while fading out.

---

## 4. Event-Driven Architecture (The Graphics <-> Logic Interface)

The Graphics Engine must subscribe to events emitted by the main Game Engine. This decouples the systems.

```$
// Example of the event-driven contract
// The Game Engine emits...                   // The Graphics Engine listener calls...
game.on('round:start', { round })             // UIRenderer.updateRound(round)
game.on('turn:start', { teamId })             // UIRenderer.updateTurn(teamId)
game.on('player:selected', { playerId })      // tokenRenderer.setState(playerId, 'selected')
game.on('player:deselected', { playerId })    // tokenRenderer.setState(playerId, 'default')
game.on('player:acted', { playerId })         // tokenRenderer.setState(playerId, 'hasActed')
game.on('token:move', { playerId, coords, duration })  // tokenRenderer.moveTo(playerId, coords, duration)
game.on('puck:passed', { fromId, toId, duration })     // puckRenderer.animatePass(fromId, toId, duration)
game.on('roll:start', { dice, results })      // diceRenderer.roll(dice, results)
game.on('bonus:applied', { position, text })  // textManager.spawn(text, { position, animationType: 'pop' })
game.on('action:blocked', { position })       // vfxManager.play('actionBlocked', { position })
game.on 'goal:scored', { teamColor })        // vfxManager.play('goalScored', { teamColor })
game.on('teamSpirit:used', { teamName, position }) // vfxManager.play('teamSpirit_' + teamName, { position })
```$

---

## 5. Animation & Timing Philosophy

*   **Responsiveness:** UI feedback (hovers, clicks) must be instant (<100ms).
*   **Flow:** Use an **animation queue**. If multiple events are fired in quick succession (e.g., a move, then a bonus text, then a block), animations must play out sequentially, not overlap chaotically.
*   **Feel:**
    *   **UI Transitions:** Fast and snappy (200-300ms).
    *   **Token Movement:** Smooth and deliberate (400-600ms).
    *   **Impact Moments (Goals, Blocks):** Fast and powerful, with a brief moment of "hit-stop" or pause to emphasize the event.