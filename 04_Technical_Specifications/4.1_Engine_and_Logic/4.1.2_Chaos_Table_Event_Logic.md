# 4.1.2 Chaos Table Event Logic

**Project:** Bones on Ice - Web Edition v1.0
**Audience:** Game Logic Developer
**Purpose:** To define the precise sequence of operations for each Chaos Table event, ensuring it integrates cleanly with the main `GameEngine` and its state machine.

---

## 1. Integration with the Game State Machine

*   **Trigger:** The `ChaosEventManager` is activated by the `GameEngine` at the very beginning of the **`PRE_ROUND`** phase if `GameState.round` is 5, 10, or 15.
*   **Process Flow:**
    1.  `GameEngine` enters `PRE_ROUND`.
    2.  `GameEngine` detects it's a chaos round and calls `chaosManager.initiate()`.
    3.  The `GameEngine`'s state machine **pauses**. It enters a temporary `AWAITING_CHAOS_RESOLUTION` state.
    4.  The `ChaosEventManager` takes control, performs its logic, and updates the `GameState` directly.
    5.  When finished, the `ChaosEventManager` notifies the `GameEngine`.
    6.  The `GameEngine` resumes its normal `PRE_ROUND` logic (handling team spirits, etc.) and then proceeds to `FACE_OFF`.

---

## 2. `initiate()` Method

This is the main entry point for the manager.

```$
function initiate(gameState) {
  // 1. Roll 2d6 to get a result (2-12).
  const result = rollDie('d6') + rollDie('d6');

  // 2. Update the game log.
  updateGameLog(`Chaos descends! The roll is ${result}.`);

  // 3. Execute the corresponding event.
  switch (result) {
    case 2:
    case 3:
      return _handlePenaltyShot(gameState);
    case 4:
    case 5:
      return _handleBreakaway(gameState);
    case 6:
    case 7:
    case 8:
      return _handleScramble(gameState);
    case 9:
      return _handlePerfectPass(gameState);
    case 10:
      return _handleComebackSurge(gameState);
    case 11:
    case 12:
      return _handleSparklingSave(gameState);
  }

  // 4. Return the modified gameState.
  return gameState;
}
```$

---

## 3. Detailed Event Logic (Private Methods)

#### **3.1. `_handlePenaltyShot(gameState)` (Result: 2-3)**

*   **Purpose:** Force an immediate, undefended 1v1 shot on goal.
*   **Logic:**
    1.  Determine the "attacking team" for this event. This is the team that was **not** the `activeTeamId` from the *previous* round (the team that was on defense).
    2.  Identify the `attackingPlayer` (the Attacker of the determined team) and the `defendingGoalie` (the Goalie of the other team).
    3.  Update `gameLog`: `"{Attacking Team Name} is awarded a Penalty Shot!"`
    4.  **Directly call the main `GameEngine`'s 1v1 resolution logic.** Pass it the `attackingPlayer` and `defendingGoalie`.
    5.  **Crucially, there is no rebound.** If the shot is saved, the puck is immediately cleared, and the event ends.
    6.  Log the result ("Goal!" or "Save!").

#### **3.2. `_handleBreakaway(gameState)` (Result: 4-5)**

*   **Purpose:** Move one player into a scoring position.
*   **Logic:**
    1.  Determine the "attacking team" using the same logic as the Penalty Shot.
    2.  Update `gameLog`: `"{Attacking Team Name} gets a Breakaway!"`
    3.  **UI Interaction:**
        *   The `ChaosEventManager` signals the UI to enter a "select a player" mode, enabling interaction only for the attacking team's skaters (Attacker and 2 Defenders).
        *   The engine waits for the UI to submit a `selectedPlayer` ID.
    4.  Once a `selectedPlayer` is received:
        *   Determine the `targetZone`. This is the opponent's Attack Zone.
        *   Update the `selectedPlayer.currentZone` property to `targetZone`.
        *   Set `gameState.puckCarrierId` to `selectedPlayer.id`.
        *   Set `gameState.puckZone` to `targetZone`.
    5.  Log the result: `"{Player Name} breaks away into the zone!"`

#### **3.3. `_handleScramble(gameState)` (Result: 6-8)**

*   **Purpose:** Randomize all player positions on the board.
*   **Logic:**
    1.  Update `gameLog`: `"A chaotic Scramble erupts on the ice!"`
    2.  Create an array `allSkaters` containing all 6 skater-objects (all players except the two Goalies).
    3.  Create an array `allZones` containing the `currentZone` string of each of those 6 skaters.
    4.  **Shuffle the `allZones` array** using a Fisher-Yates shuffle algorithm.
    5.  Iterate through `allSkaters` and assign `allSkaters[i].currentZone = shuffledZones[i]`.
    6.  **Puck Reset:** Set `gameState.puckCarrierId = null`.
    7.  **Zonal Bonus Nullification:** Set `gameState.bonusesNullifiedThisRound = true`. This flag must be checked by the `GameEngine` when calculating roll bonuses and reset during the next `POST_ROUND_RECOVERY`.

#### **3.4. `_handlePerfectPass(gameState)` (Result: 9)**

*   **Logic:**
    1.  Update `gameLog`: `"The stars align for a Perfect Pass!"`
    2.  Set a flag on the `activeTeam`'s `Team` object: `team.customProperties.perfectPassAvailable = true`.
    3.  The `GameEngine`'s logic for resolving a `Pass` action must check for this flag. If true, the pass automatically succeeds, and the flag is set to false.

#### **3.5. `_handleComebackSurge(gameState)` (Result: 10)**

*   **Logic:**
    1.  Check the `gameState.score`.
    2.  **If a team is losing:**
        *   Identify the `losingTeamId`.
        *   Apply a status effect to that team's `Team` object: `{ type: 'bonus_roll', value: 2, duration: 2 }`. The `duration` decrements each time a roll made by that team benefits from the bonus.
    3.  **If the score is tied or the current player's team is leading:**
        *   The active player's team gains stamina: `team.stamina = min(MAX_STAMINA, team.stamina + 3)`.

#### **3.6. `_handleSparklingSave(gameState)` (Result: 11-12)**

*   **Logic:**
    1.  Determine the "defending team" (the team that *was* the active team last round).
    2.  Apply a status effect to that team's `Goalie` player object: `{ type: 'auto_save', duration: 1 }`.
    3.  Apply a status effect to the *opposing* team's `Attacker` player object: `{ type: 'debuff_marksmanship', value: -2, duration: 1 }`.
    4.  The `GameEngine` must check for these status effects during the 1v1 phase and `calculatePlayerRoll` function, respectively.